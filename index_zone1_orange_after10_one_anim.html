<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Snake Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      touch-action: manipulation;
    }
    canvas {
      display: block;
      background: #000;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    button {
      background: rgba(20, 20, 20, 0.85);
      color: #0ff;
      border: 1px solid rgba(0, 255, 255, 0.85);
      padding: 8px 16px;
      cursor: pointer;
      font-family: inherit;
      transition: transform 0.12s, background 0.2s, color 0.2s, box-shadow 0.2s;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 12px rgba(0, 255, 255, 0.15);
    }
    button:hover {
      background: rgba(0, 255, 255, 0.9);
      color: #000;
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(0, 255, 255, 0.35);
    }
    button:active {
      transform: translateY(0px) scale(0.98);
    }
    .start-prompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0ff;
      font-size: 24px;
      text-align: center;
      z-index: 10;
      text-shadow: 0 0 10px #0ff;
      user-select: none;
    }

    /* Subtle HUD */
    .hud {
      position: fixed;
      top: 14px;
      left: 14px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 6px;
      pointer-events: none;
      font-family: Arial, sans-serif;
    }
    .hud .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(10, 10, 10, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 12px rgba(0, 255, 255, 0.12);
      letter-spacing: 0.2px;
      font-size: 13px;
      width: fit-content;
    }
    .hud .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #0ff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.55);
    }
    .hud .subtle {
      opacity: 0.85;
      font-variant-numeric: tabular-nums;
    }

    .hud-right {
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 10;
      pointer-events: none;
    }
    .hud-right .pill {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(10, 10, 10, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      color: rgba(255, 255, 255, 0.9);
      font-size: 13px;
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="pill"><span class="dot" id="areaDot"></span><span id="areaLabel">Area 1</span></div>
    <div class="pill"><span class="subtle">Score:</span> <span id="scoreLabel">0</span></div>
  </div>
  <div class="hud-right">
    <div class="pill" id="fpsLabel">FPS: --</div>
  </div>

  <div class="controls">
    <button id="musicBtn">Music: ON</button>
    <button id="sfxBtn">SFX: ON</button>
  </div>
  <div class="start-prompt">Click anywhere or press any arrow key to start</div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

    // HUD elements
    const areaLabelEl = document.getElementById('areaLabel');
    const areaDotEl = document.getElementById('areaDot');
    const scoreLabelEl = document.getElementById('scoreLabel');
    const fpsLabelEl = document.getElementById('fpsLabel');

    const gridSize = 20;
    const PELLET_COUNT = 5;
    const KILLER_PELLET_COUNT = 8;

    const ORANGE_TRIGGER_COUNT = 10; // In Area 1, spawn 1 orange pellet after eating 10 blue pellets

    let tileCountX, tileCountY;

    // Area system (declared early so early spawners can reference it safely)
    let currentArea = 1;

    // Area system (declared early so early spawners can reference it safely)

    // For smoother visuals: we render at 60fps (requestAnimationFrame),
    // but update the game on a fixed timestep so gameplay stays consistent.
    const BASE_STEP_MS = 100; // base snake move interval (~10 moves/sec)

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      tileCountX = Math.floor(window.innerWidth / gridSize);
      tileCountY = Math.floor(window.innerHeight / gridSize);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Logical state (grid-based)
    let snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
    let prevSnake = snake.map(p => ({ ...p }));

    let direction = { x: 0, y: 0 };
    let queuedDirection = null; // for smoother turning (buffer next input)

    let pellets = [];
    let orangePellets = [];
    let killerPellets = [];
    let score = 0;

    // Area 1 orange pellet pacing
    let blueEatenTowardOrange = 0;
    let orangeSpawnAnim = { active: false, x: 0, y: 0, t: 0, duration: 900 }; // ms


    function spawnOnEdge() {
      const edge = Math.floor(Math.random() * 4);
      switch (edge) {
        case 0: return { x: Math.floor(Math.random() * tileCountX), y: 0 };
        case 1: return { x: Math.floor(Math.random() * tileCountX), y: tileCountY - 1 };
        case 2: return { x: 0, y: Math.floor(Math.random() * tileCountY) };
        case 3: return { x: tileCountX - 1, y: Math.floor(Math.random() * tileCountY) };
      }
    }

    function spawnFood() {
      return {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY)
      };
    }

    function spawnOrangePelletSafe() {
      // Orange pellets only exist in Area 1
      if (currentArea !== 1) return null;

      let attempts = 0;
      while (attempts++ < 400) {
        const p = spawnFood();

        // Avoid snake
        if (isCellOnSnake(p.x, p.y)) continue;

        // Avoid existing blue pellets
        let dup = false;
        for (let i = 0; i < pellets.length; i++) {
          if (pellets[i].x === p.x && pellets[i].y === p.y) { dup = true; break; }
        }
        if (dup) continue;

        // Avoid other orange pellets
        for (let i = 0; i < orangePellets.length; i++) {
          const op = orangePellets[i];
          if (op && op.x === p.x && op.y === p.y) { dup = true; break; }
        }
        if (dup) continue;

        // Avoid killers
        for (let i = 0; i < killerPellets.length; i++) {
          if (killerPellets[i].x === p.x && killerPellets[i].y === p.y) { dup = true; break; }
        }
        if (dup) continue;

        return p;
      }

      // Fallback: if we fail to find a safe spot, just place it anywhere
      return spawnFood();
    }
    function trySpawnOrangePellet() {
      // Area 1 only; only one orange pellet at a time
      if (currentArea !== 1) return;
      if (orangePellets.length) return;
      if (blueEatenTowardOrange < ORANGE_TRIGGER_COUNT) return;

      const op = spawnOrangePelletSafe();
      if (!op) return;

      orangePellets = [op];
      blueEatenTowardOrange = 0;

      // Spawn feedback: sound + pop-in animation
      playOrangeSpawnSound();
      orangeSpawnAnim = { active: true, x: op.x, y: op.y, t: 0, duration: 900 };
      addShake(2.8, 110);
      emitParticles(op.x * gridSize + gridSize / 2, op.y * gridSize + gridSize / 2, 20, 190, 380, 1.1, 3.2);
    }


    function spawnPellets() {
      pellets = [];
      orangePellets = [];
      killerPellets = [];

      for (let i = 0; i < PELLET_COUNT; i++) pellets.push(spawnFood());
      for (let i = 0; i < KILLER_PELLET_COUNT; i++) killerPellets.push(spawnOnEdge());
      // Orange pellet pacing (Area 1): spawn later after eating enough blue pellets
      blueEatenTowardOrange = 0;
    }
    spawnPellets();

    // Audio System
    let audioCtx = null;
    let musicEnabled = true;
    let sfxEnabled = true;
    let gameStarted = false;

    // Animations (time-based)
    let zapAnimation = { active: false, x: 0, y: 0, t: 0, duration: 240 }; // ms
    let moveCounter = 0;
    let explosions = [];     // {x,y,t}
    let goldExplosions = []; // {x,y,t}
    let thunderFlashes = []; // {t, opacity}

    // Pro polish: camera shake, particles, animated grid
    let cameraShake = { x: 0, y: 0, tx: 0, ty: 0, intensity: 0, t: 0, duration: 0 };
    let particles = []; // {x,y,vx,vy,life,maxLife,size}
    let bgTime = 0;

    let explosionTimer = null;

    // Power mode
    let powerMode = false;
    let powerModeTimer = null;
    let powerModeWarning = false;
    let powerModeWarningStart = 0;
    let bodyPassthroughGrace = false;
    let bodyPassthroughGraceTimer = null;
    const BODY_GRACE_DURATION = 3000;
    let powerPellet = null;
    let powerPelletTimer = null;
    let powerPelletDespawnTimer = null;

    // Area and Portal system
    let bluePortal = null;
    let redPortal = null;
    let blackPortal = null;
    let portalSpawnTimer = null;
    let portalAnimTime = 0;

    const PORTAL_SPAWN_DELAY = 30000;
    const PORTAL_WIDTH = 3;
    const PORTAL_HEIGHT = 5;
    const AREA_2_COLOR = "#000066";
    const AREA_3_COLOR = "#660000";

    // Area 2 gold killer
    let goldKiller = null;
    let goldKillerHP = 10;
    let goldKillerInvincible = false;
    let returnPortal = null;
    let area2NoPelletRespawn = false;
    const GOLD_KILLER_SIZE = 2;
    const GOLD_KILLER_MAX_HP = 10;

    const POWER_MODE_DURATION = 17000;
    const POWER_MODE_WARNING_DURATION = 5000;
    const POWER_PELLET_SPAWN_INTERVAL = 30000;
    const POWER_PELLET_LIFETIME = 30000;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (musicEnabled) startMusic();
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playOrangeSpawnSound() {
      if (!sfxEnabled || !audioCtx) return;

      // Bright shimmering chime so the player knows something special spawned
      const now = audioCtx.currentTime;
      for (let i = 0; i < 3; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.type = "triangle";
        const t0 = now + i * 0.04;
        const f0 = 520 + i * 220;
        osc.frequency.setValueAtTime(f0, t0);
        osc.frequency.exponentialRampToValueAtTime(f0 * 1.9, t0 + 0.12);

        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(0.14, t0 + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

        osc.start(t0);
        osc.stop(t0 + 0.25);
      }
    }

    function playEatSound() {
      if (!sfxEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(400, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.1);
    }

    function playGameOverSound() {
      if (!sfxEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.4);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.4);
    }

    function playZapSound() {
      if (!sfxEnabled || !audioCtx) return;
      for (let i = 0; i < 3; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(80 + Math.random() * 200, audioCtx.currentTime + i * 0.08);
        osc.frequency.setValueAtTime(300 + Math.random() * 400, audioCtx.currentTime + i * 0.08 + 0.02);
        osc.frequency.setValueAtTime(50 + Math.random() * 100, audioCtx.currentTime + i * 0.08 + 0.06);
        gain.gain.setValueAtTime(0.25, audioCtx.currentTime + i * 0.08);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.08 + 0.08);
        osc.start(audioCtx.currentTime + i * 0.08);
        osc.stop(audioCtx.currentTime + i * 0.08 + 0.1);
      }
    }

    function triggerZap(x, y) {
      zapAnimation = { active: true, x, y, t: 0, duration: 240 };
      playZapSound();
      // Extra visual punch
      addShake(16, 220);
      const cx = x * gridSize + gridSize / 2;
      const cy = y * gridSize + gridSize / 2;
      emitParticles(cx, cy, 40, 520, 260, 1.5, 3.5);
    }

    // --- Visual polish helpers ---
    function addShake(intensityPx, durationMs) {
      // Additive shake: keep the strongest impulse
      cameraShake.intensity = Math.max(cameraShake.intensity, intensityPx);
      cameraShake.duration = Math.max(cameraShake.duration, durationMs);
      cameraShake.t = 0;
    }

    function emitParticles(px, py, count, speed, lifeMs, sizeMin, sizeMax) {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = speed * (0.35 + Math.random() * 0.65);
        particles.push({
          x: px,
          y: py,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s,
          life: 0,
          maxLife: lifeMs * (0.7 + Math.random() * 0.6),
          size: sizeMin + Math.random() * (sizeMax - sizeMin),
        });
      }
    }

    function playExplosionSound() {
      if (!sfxEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.3);
    }

    function explodeRandomKiller() {
      if (!gameStarted || killerPellets.length === 0) return;
      let closestIndex = 0;
      let closestDist = Infinity;
      for (let i = 0; i < killerPellets.length; i++) {
        const dx = killerPellets[i].x - snake[0].x;
        const dy = killerPellets[i].y - snake[0].y;
        const dist = dx * dx + dy * dy;
        if (dist < closestDist) {
          closestDist = dist;
          closestIndex = i;
        }
      }
      const killer = killerPellets[closestIndex];
      explosions.push({ x: killer.x, y: killer.y, t: 0 });
      addShake(6, 140);
      emitParticles(killer.x * gridSize + gridSize / 2, killer.y * gridSize + gridSize / 2, 18, 220, 420, 1.5, 3.5);
      playExplosionSound();
      killerPellets.splice(closestIndex, 1);
      setTimeout(() => { respawnKillerFarAway(); }, 2000);
    }

    function respawnKillerFarAway() {
      if (!gameStarted || currentArea !== 1) return;
      let attempts = 0;
      let newPos;
      do {
        newPos = spawnOnEdge();
        const dx = newPos.x - snake[0].x;
        const dy = newPos.y - snake[0].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        attempts++;
        if (distance >= 15 || attempts > 50) {
          killerPellets.push(newPos);
          break;
        }
      } while (attempts <= 50);
    }

    function startExplosionTimer() {
      if (explosionTimer) clearInterval(explosionTimer);
      explosionTimer = setInterval(explodeRandomKiller, 2000);
    }
    function stopExplosionTimer() {
      if (explosionTimer) {
        clearInterval(explosionTimer);
        explosionTimer = null;
      }
    }

    function playPowerUpSound() {
      if (!sfxEnabled || !audioCtx) return;
      for (let i = 0; i < 5; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.setValueAtTime(200 + i * 100, audioCtx.currentTime + i * 0.1);
        osc.frequency.exponentialRampToValueAtTime(400 + i * 150, audioCtx.currentTime + i * 0.1 + 0.1);
        gain.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.1 + 0.15);
        osc.start(audioCtx.currentTime + i * 0.1);
        osc.stop(audioCtx.currentTime + i * 0.1 + 0.15);
      }
    }

    function playKillerEatSound() {
      if (!sfxEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); osc2.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc2.type = 'square';
      osc.frequency.setValueAtTime(80, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2);
      osc2.frequency.setValueAtTime(160, audioCtx.currentTime);
      osc2.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
      osc.start(audioCtx.currentTime);
      osc2.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.25);
      osc2.stop(audioCtx.currentTime + 0.2);
    }

    function playThunderSound() {
      if (!sfxEnabled || !audioCtx) return;
      const bufferSize = audioCtx.sampleRate * 0.3;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
      }
      const noise = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      noise.buffer = buffer;
      filter.type = 'lowpass';
      filter.frequency.value = 500;
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      noise.start();
    }

    function addThunderFlash() {
      if (!powerMode) return;
      thunderFlashes.push({ t: 0, opacity: 0.8 });
      addShake(4, 120);
      playThunderSound();
    }

    function spawnPowerPellet() {
      if (!gameStarted || powerPellet || powerMode) return;
      let attempts = 0;
      do {
        powerPellet = {
          x: Math.floor(Math.random() * (tileCountX - 2)),
          y: Math.floor(Math.random() * (tileCountY - 2))
        };
        const dx = powerPellet.x - snake[0].x;
        const dy = powerPellet.y - snake[0].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        attempts++;
        if (dist >= 10 || attempts > 30) break;
      } while (attempts <= 30);

      powerPelletDespawnTimer = setTimeout(() => {
        powerPellet = null;
      }, POWER_PELLET_LIFETIME);
    }

    function startPowerPelletTimer() {
      if (powerPelletTimer) clearInterval(powerPelletTimer);
      powerPelletTimer = setInterval(spawnPowerPellet, POWER_PELLET_SPAWN_INTERVAL);
    }

    function stopPowerPelletTimer() {
      if (powerPelletTimer) {
        clearInterval(powerPelletTimer);
        powerPelletTimer = null;
      }
      if (powerPelletDespawnTimer) {
        clearTimeout(powerPelletDespawnTimer);
        powerPelletDespawnTimer = null;
      }
    }

    function activatePowerMode() {
      powerMode = true;
      powerModeWarning = false;
      powerPellet = null;
      playPowerUpSound();
      if (musicEnabled) startPowerMusic();
      stopExplosionTimer();

      bluePortal = null;
      stopPortalTimer();

      if (powerPelletDespawnTimer) {
        clearTimeout(powerPelletDespawnTimer);
        powerPelletDespawnTimer = null;
      }
      if (powerModeTimer) clearTimeout(powerModeTimer);

      powerModeTimer = setTimeout(() => {
        powerModeWarning = true;
        powerModeWarningStart = Date.now();

        powerModeTimer = setTimeout(() => {
          const head = snake[0];
          let overlapping = false;
          for (let i = 1; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) { overlapping = true; break; }
          }

          if (overlapping) {
            bodyPassthroughGrace = true;
            if (bodyPassthroughGraceTimer) clearTimeout(bodyPassthroughGraceTimer);
            bodyPassthroughGraceTimer = setTimeout(() => {
              bodyPassthroughGrace = false;
              bodyPassthroughGraceTimer = null;
            }, BODY_GRACE_DURATION);
          }

          powerMode = false;
          powerModeWarning = false;
          powerModeTimer = null;
          startExplosionTimer();
          startPortalTimer();
          if (musicEnabled) startMusic();
        }, POWER_MODE_WARNING_DURATION);
      }, POWER_MODE_DURATION);
    }

    // Portal system
    function playPortalSpawnSound() {
      if (!sfxEnabled || !audioCtx) return;
      for (let i = 0; i < 3; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sine';
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        const startTime = audioCtx.currentTime + i * 0.15;
        osc.frequency.setValueAtTime(150 + i * 50, startTime);
        osc.frequency.exponentialRampToValueAtTime(80, startTime + 0.4);
        gain.gain.setValueAtTime(0.15, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.5);
        osc.start(startTime);
        osc.stop(startTime + 0.5);
      }
    }

    function playPortalEnterSound() {
      if (!sfxEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      osc2.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sine';
      osc2.type = 'triangle';
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.3);
      osc2.frequency.setValueAtTime(100, audioCtx.currentTime);
      osc2.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
      osc.start(audioCtx.currentTime);
      osc2.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.4);
      osc2.stop(audioCtx.currentTime + 0.4);
    }

    function spawnBluePortal() {
      if (currentArea !== 1 || bluePortal) return;
      if (redPortal) return;
      if (powerMode || powerModeWarning) return;
      let attempts = 0;
      do {
        bluePortal = {
          x: Math.floor(Math.random() * (tileCountX - PORTAL_WIDTH)),
          y: Math.floor(Math.random() * (tileCountY - PORTAL_HEIGHT))
        };
        const dx = bluePortal.x + PORTAL_WIDTH / 2 - snake[0].x;
        const dy = bluePortal.y + PORTAL_HEIGHT / 2 - snake[0].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        attempts++;
        if (dist >= 12 || attempts > 50) break;
      } while (attempts <= 50);
      playPortalSpawnSound();
    }

    function spawnRedPortal() {
      if (currentArea !== 1 || redPortal) return;
      if (bluePortal) return;
      if (powerMode || powerModeWarning) return;
      let attempts = 0;
      do {
        redPortal = {
          x: Math.floor(Math.random() * (tileCountX - PORTAL_WIDTH)),
          y: Math.floor(Math.random() * (tileCountY - PORTAL_HEIGHT))
        };
        const dx = redPortal.x + PORTAL_WIDTH / 2 - snake[0].x;
        const dy = redPortal.y + PORTAL_HEIGHT / 2 - snake[0].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        attempts++;
        if (dist >= 12 || attempts > 50) break;
      } while (attempts <= 50);
      playPortalSpawnSound();
    }

    function spawnRandomPortal() {
      if (currentArea !== 1) { startPortalTimer(); return; }
      if (bluePortal || redPortal || powerMode || powerModeWarning) { startPortalTimer(); return; }
      if (Math.random() < 0.5) spawnBluePortal(); else spawnRedPortal();
      startPortalTimer();
    }

    function startPortalTimer() {
      if (portalSpawnTimer) clearTimeout(portalSpawnTimer);
      portalSpawnTimer = setTimeout(spawnRandomPortal, PORTAL_SPAWN_DELAY);
    }

    function stopPortalTimer() {
      if (portalSpawnTimer) {
        clearTimeout(portalSpawnTimer);
        portalSpawnTimer = null;
      }
    }

    function transitionToArea2() {
      currentArea = 2;
      orangePellets = [];
      blueEatenTowardOrange = 0;
      area2NoPelletRespawn = false;
      bluePortal = null;
      redPortal = null;
      stopPortalTimer();
      stopExplosionTimer();
      stopPowerPelletTimer();

      for (let killer of killerPellets) {
        explosions.push({ x: killer.x, y: killer.y, t: 0 });
      }
      if (killerPellets.length > 0) {
        addShake(10, 220);
        emitParticles(snake[0].x * gridSize + gridSize / 2, snake[0].y * gridSize + gridSize / 2, 28, 260, 520, 1.5, 3.8);
        playExplosionSound();
      }

      killerPellets = [];
      pellets = [];
      powerPellet = null;
      powerMode = false;
      powerModeWarning = false;

      blackPortal = {
        x: Math.floor(Math.random() * (tileCountX - PORTAL_WIDTH)),
        y: Math.floor(Math.random() * (tileCountY - PORTAL_HEIGHT))
      };

      // Fixed spawn in Area 2
      const spawnX = Math.floor(tileCountX / 2);
      const spawnY = Math.floor(tileCountY / 2);
      const oldHead = snake[0];
      const dx = spawnX - oldHead.x;
      const dy = spawnY - oldHead.y;
      for (let segment of snake) {
        segment.x += dx;
        segment.y += dy;
      }
      prevSnake = snake.map(p => ({ ...p }));

      spawnGoldKiller();
      addShake(12, 240);
      emitParticles(snake[0].x * gridSize + gridSize / 2, snake[0].y * gridSize + gridSize / 2, 32, 320, 520, 1.2, 3.6);
      playPortalEnterSound();
    }

    function transitionToArea3() {
      currentArea = 3;
      orangePellets = [];
      blueEatenTowardOrange = 0;
      bluePortal = null;
      redPortal = null;
      stopPortalTimer();
      stopExplosionTimer();
      stopPowerPelletTimer();

      killerPellets = [];
      pellets = [];
      powerPellet = null;
      powerMode = false;
      powerModeWarning = false;

      blackPortal = null;
      returnPortal = null;
      goldKiller = null;
      goldKillerInvincible = false;
      goldExplosions = [];

      addShake(12, 240);
      emitParticles(snake[0].x * gridSize + gridSize / 2, snake[0].y * gridSize + gridSize / 2, 32, 320, 520, 1.2, 3.6);
      playPortalEnterSound();
      addShake(12, 180);
      emitParticles(snake[0].x * gridSize + gridSize * 0.5, snake[0].y * gridSize + gridSize * 0.5, 28, 420, 260, 1.2, 3.2);

    }

    function spawnGoldKiller() {
      let attempts = 0;
      const MIN_DIST = 18;
      do {
        goldKiller = {
          x: Math.floor(Math.random() * (tileCountX - GOLD_KILLER_SIZE)),
          y: Math.floor(Math.random() * (tileCountY - GOLD_KILLER_SIZE))
        };
        const dx = goldKiller.x - snake[0].x;
        const dy = goldKiller.y - snake[0].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        attempts++;
        if (dist >= MIN_DIST || attempts > 80) break;
      } while (attempts <= 80);
      goldKillerHP = GOLD_KILLER_MAX_HP;
    }

    function playGoldExplosionSound() {
      if (!sfxEnabled || !audioCtx) return;
      for (let i = 0; i < 4; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'square';
        const startTime = audioCtx.currentTime + i * 0.05;
        osc.frequency.setValueAtTime(300 - i * 40, startTime);
        osc.frequency.exponentialRampToValueAtTime(100, startTime + 0.2);
        gain.gain.setValueAtTime(0.25, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.25);
        osc.start(startTime);
        osc.stop(startTime + 0.25);
      }
    }

    function defeatGoldBossCheat() {
      if (currentArea !== 2 || !goldKiller) return;
      goldKillerInvincible = false;
      goldKillerHP = 1;
      hitGoldKiller();
    }

    function hitGoldKiller() {
      if (goldKillerInvincible) return;

      const explosionX = goldKiller.x + GOLD_KILLER_SIZE / 2;
      const explosionY = goldKiller.y + GOLD_KILLER_SIZE / 2;
      goldExplosions.push({ x: explosionX, y: explosionY, t: 0 });
      playGoldExplosionSound();

      const dx = goldKiller.x - snake[0].x;
      const dy = goldKiller.y - snake[0].y;
      const bounceDistance = 8;

      if (Math.abs(dx) > Math.abs(dy)) goldKiller.x += (dx > 0 ? bounceDistance : -bounceDistance);
      else goldKiller.y += (dy > 0 ? bounceDistance : -bounceDistance);

      goldKiller.x = Math.max(0, Math.min(tileCountX - GOLD_KILLER_SIZE, goldKiller.x));
      goldKiller.y = Math.max(0, Math.min(tileCountY - GOLD_KILLER_SIZE, goldKiller.y));

      goldKillerHP--;

      if (goldKillerHP === 5 || goldKillerHP === 1) {
        goldKillerInvincible = true;
        spawnArea2Killers();
        playForceFieldSound();
      }

      if (goldKillerHP <= 0) {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            goldExplosions.push({
              x: explosionX + (Math.random() - 0.5) * 4,
              y: explosionY + (Math.random() - 0.5) * 4,
              t: 0
            });
            playGoldExplosionSound();
          }, i * 100);
        }

        goldKiller = null;
        goldKillerInvincible = false;

        setTimeout(() => {
          spawnReturnPortal();
          spawnRewardPelletsArea2(25);
          area2NoPelletRespawn = true;
        }, 600);
      }
    }

    function spawnArea2Killers() {
      for (let i = 0; i < 8; i++) {
        let newPos;
        let attempts = 0;
        do {
          newPos = spawnOnEdge();
          const dx = newPos.x - snake[0].x;
          const dy = newPos.y - snake[0].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          attempts++;
          if (distance >= 10 || attempts > 30) break;
        } while (attempts <= 30);
        killerPellets.push(newPos);
      }
    }

    function playForceFieldSound() {
      if (!sfxEnabled || !audioCtx) return;
      for (let i = 0; i < 5; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sine';
        const startTime = audioCtx.currentTime + i * 0.08;
        osc.frequency.setValueAtTime(600 + i * 100, startTime);
        osc.frequency.exponentialRampToValueAtTime(400 + i * 50, startTime + 0.15);
        gain.gain.setValueAtTime(0.12, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
        osc.start(startTime);
        osc.stop(startTime + 0.2);
      }
    }

    function spawnReturnPortal() {
      let attempts = 0;
      do {
        returnPortal = {
          x: Math.floor(Math.random() * (tileCountX - PORTAL_WIDTH)),
          y: Math.floor(Math.random() * (tileCountY - PORTAL_HEIGHT))
        };
        const dx = returnPortal.x + PORTAL_WIDTH / 2 - snake[0].x;
        const dy = returnPortal.y + PORTAL_HEIGHT / 2 - snake[0].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        attempts++;
        if (dist >= 10 || attempts > 50) break;
      } while (attempts <= 50);
      playPortalSpawnSound();
    }

    function transitionToArea1() {
      currentArea = 1;
      area2NoPelletRespawn = false;
      returnPortal = null;
      bluePortal = null;
      redPortal = null;

      const spawnX = Math.floor(Math.random() * (tileCountX - 4)) + 2;
      const spawnY = Math.floor(Math.random() * (tileCountY - 4)) + 2;

      const oldHead = snake[0];
      const dx = spawnX - oldHead.x;
      const dy = spawnY - oldHead.y;
      for (let segment of snake) {
        segment.x += dx;
        segment.y += dy;
      }
      prevSnake = snake.map(p => ({ ...p }));

      spawnPellets();
      startExplosionTimer();
      startPowerPelletTimer();
      startPortalTimer();

      addShake(12, 240);
      emitParticles(snake[0].x * gridSize + gridSize / 2, snake[0].y * gridSize + gridSize / 2, 32, 320, 520, 1.2, 3.6);
      playPortalEnterSound();
    }

    function isSnakeInPortal(portal) {
      if (!portal) return false;
      for (let segment of snake) {
        if (segment.x >= portal.x && segment.x < portal.x + PORTAL_WIDTH &&
            segment.y >= portal.y && segment.y < portal.y + PORTAL_HEIGHT) {
          return true;
        }
      }
      return false;
    }

    function isCellOnSnake(x, y) {
      for (let i = 0; i < snake.length; i++) {
        if (snake[i].x === x && snake[i].y === y) return true;
      }
      return false;
    }

    function isCellInPortalRect(x, y, portal) {
      if (!portal) return false;
      return (x >= portal.x && x < portal.x + PORTAL_WIDTH &&
              y >= portal.y && y < portal.y + PORTAL_HEIGHT);
    }

    function spawnRewardPelletsArea2(count) {
      pellets = [];
      let attempts = 0;
      while (pellets.length < count && attempts < count * 200) {
        attempts++;
        const p = spawnFood();
        if (isCellOnSnake(p.x, p.y)) continue;
        if (isCellInPortalRect(p.x, p.y, blackPortal)) continue;
        if (isCellInPortalRect(p.x, p.y, returnPortal)) continue;
        if (goldKiller) {
          if (p.x >= goldKiller.x && p.x < goldKiller.x + GOLD_KILLER_SIZE &&
              p.y >= goldKiller.y && p.y < goldKiller.y + GOLD_KILLER_SIZE) {
            continue;
          }
        }
        let dup = false;
        for (let i = 0; i < pellets.length; i++) {
          if (pellets[i].x === p.x && pellets[i].y === p.y) { dup = true; break; }
        }
        if (dup) continue;
        pellets.push(p);
      }
    }

    // Background music
    let bassOsc = null;
    let musicLoopTimeout = null;
    let powerBassOsc = null;
    let powerMusicLoopTimeout = null;
    let powerPulseTimeout = null;

    function startMusic() {
      if (!audioCtx) return;
      stopMusic();

      bassOsc = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      const bassFilter = audioCtx.createBiquadFilter();

      bassOsc.type = 'sawtooth';
      bassOsc.frequency.value = 55;
      bassFilter.type = 'lowpass';
      bassFilter.frequency.value = 150;
      bassGain.gain.value = 0.12;

      bassOsc.connect(bassFilter);
      bassFilter.connect(bassGain);
      bassGain.connect(audioCtx.destination);
      bassOsc.start();

      const notes = [110, 138.59, 164.81, 220, 277.18, 329.63, 277.18, 220];
      const noteLength = 0.15;

      function playNote(freq, time) {
        const osc = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc2.type = 'square';
        osc.frequency.value = freq;
        osc2.frequency.value = freq * 1.005;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, time);
        filter.frequency.exponentialRampToValueAtTime(200, time + noteLength);

        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.06, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, time + noteLength);

        osc.start(time);
        osc2.start(time);
        osc.stop(time + noteLength);
        osc2.stop(time + noteLength);
      }

      function scheduleLoop() {
        if (!musicEnabled) return;
        const loopDuration = notes.length * noteLength;
        const startTime = audioCtx.currentTime + 0.05;
        notes.forEach((freq, i) => playNote(freq, startTime + i * noteLength));
        musicLoopTimeout = setTimeout(scheduleLoop, loopDuration * 1000 - 50);
      }

      scheduleLoop();
    }

    function startPowerMusic() {
      if (!audioCtx) return;
      stopMusic();

      powerBassOsc = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      const bassFilter = audioCtx.createBiquadFilter();

      powerBassOsc.type = 'sawtooth';
      powerBassOsc.frequency.value = 65;
      bassFilter.type = 'lowpass';
      bassFilter.frequency.value = 220;
      bassGain.gain.value = 0.18;

      powerBassOsc.connect(bassFilter);
      bassFilter.connect(bassGain);
      bassGain.connect(audioCtx.destination);
      powerBassOsc.start();

      const notes = [220, 261.63, 329.63, 392, 523.25, 392, 329.63, 261.63];
      const noteLength = 0.10;

      function playNote(freq, time) {
        const osc = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'square';
        osc2.type = 'sawtooth';
        osc.frequency.value = freq;
        osc2.frequency.value = freq * 0.997;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1400, time);
        filter.frequency.exponentialRampToValueAtTime(350, time + noteLength);

        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.09, time + 0.008);
        gain.gain.exponentialRampToValueAtTime(0.01, time + noteLength);

        osc.start(time);
        osc2.start(time);
        osc.stop(time + noteLength);
        osc2.stop(time + noteLength);
      }

      function schedulePulse() {
        if (!musicEnabled) return;
        const t = audioCtx.currentTime + 0.01;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(90, t);
        osc.frequency.exponentialRampToValueAtTime(45, t + 0.08);

        gain.gain.setValueAtTime(0.0, t);
        gain.gain.linearRampToValueAtTime(0.22, t + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.10);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(t);
        osc.stop(t + 0.11);

        powerPulseTimeout = setTimeout(schedulePulse, 200);
      }

      function scheduleLoop() {
        if (!musicEnabled) return;
        const loopDuration = notes.length * noteLength;
        const startTime = audioCtx.currentTime + 0.05;
        notes.forEach((freq, i) => playNote(freq, startTime + i * noteLength));
        powerMusicLoopTimeout = setTimeout(scheduleLoop, loopDuration * 1000 - 40);
      }

      schedulePulse();
      scheduleLoop();
    }

    function stopMusic() {
      if (musicLoopTimeout) { clearTimeout(musicLoopTimeout); musicLoopTimeout = null; }
      if (powerMusicLoopTimeout) { clearTimeout(powerMusicLoopTimeout); powerMusicLoopTimeout = null; }
      if (powerPulseTimeout) { clearTimeout(powerPulseTimeout); powerPulseTimeout = null; }

      if (bassOsc) { try { bassOsc.stop(); } catch (e) {} bassOsc = null; }
      if (powerBassOsc) { try { powerBassOsc.stop(); } catch (e) {} powerBassOsc = null; }
    }

    // Control buttons
    const musicBtn = document.getElementById('musicBtn');
    const sfxBtn = document.getElementById('sfxBtn');
    const startPrompt = document.querySelector('.start-prompt');

    musicBtn.addEventListener('click', () => {
      initAudio();
      musicEnabled = !musicEnabled;
      musicBtn.textContent = musicEnabled ? 'Music: ON' : 'Music: OFF';
      if (musicEnabled) {
        if (powerMode) startPowerMusic();
        else startMusic();
      } else {
        stopMusic();
      }
    });

    sfxBtn.addEventListener('click', () => {
      initAudio();
      sfxEnabled = !sfxEnabled;
      sfxBtn.textContent = sfxEnabled ? 'SFX: ON' : 'SFX: OFF';
    });

    // --- Smooth engine helpers ---
    function lerp(a, b, t) { return a + (b - a) * t; }

    function wrapDelta(a, b, max) {
      // If we wrapped (jumped from 0 to max-1 or vice versa), don't interpolate across the screen.
      // Return null to indicate "snap".
      const d = b - a;
      if (Math.abs(d) > 1) return null;
      return d;
    }

    function getStepMs() {
      // During power mode (not warning), double speed (half step time)
      if (powerMode && !powerModeWarning) return BASE_STEP_MS / 2;
      return BASE_STEP_MS;
    }

    function applyQueuedDirection() {
      if (!queuedDirection) return;
      const nd = queuedDirection;
      // Prevent reversal
      if (nd.x === -direction.x && nd.y === -direction.y) {
        queuedDirection = null;
        return;
      }
      // Prevent moving into same axis block (classic snake rule)
      // Allow change if currently not moving or change axis
      if (direction.x === 0 && direction.y === 0) {
        direction = nd;
      } else {
        // allow perpendicular changes only
        if ((direction.x !== 0 && nd.y !== 0) || (direction.y !== 0 && nd.x !== 0)) direction = nd;
      }
      queuedDirection = null;
    }

    // --- Fixed update ---
    function updateLogicStep() {
      // Handle zap animation (logic pause)
      if (zapAnimation.active) return;

      // Apply buffered direction first so the very first arrow key press can start the game.
      // (Previously we returned early before consuming queued input, which made the game appear "stuck".)
      applyQueuedDirection();

      // Don't update if game hasn't started
      if (direction.x === 0 && direction.y === 0) return;

      if (!gameStarted) {
        gameStarted = true;
        startExplosionTimer();
        startPowerPelletTimer();
        startPortalTimer();
      }

      // Save previous snake positions for render interpolation
      prevSnake = snake.map(p => ({ ...p }));

      moveCounter++;

      // Killer movement cadence: previously tied to frames; keep the same feel by tying to logic steps.
      const killerMoveInterval = (powerMode && !powerModeWarning) ? 4 : 2; // slowed overall: normal every 2 steps, power-mode every 4 steps
      if (moveCounter % killerMoveInterval === 0) {
        for (let i = killerPellets.length - 1; i >= 0; i--) {
          const killer = killerPellets[i];
          const dx = snake[0].x - killer.x;
          const dy = snake[0].y - killer.y;
          const direction_mult = (powerMode && !powerModeWarning) ? -1 : 1;

          if (Math.abs(dx) > Math.abs(dy)) killer.x += (dx > 0 ? 1 : -1) * direction_mult;
          else if (dy !== 0) killer.y += (dy > 0 ? 1 : -1) * direction_mult;

          killer.x = Math.max(0, Math.min(tileCountX - 1, killer.x));
          killer.y = Math.max(0, Math.min(tileCountY - 1, killer.y));

          if (!powerMode) {
            if (killer.x === snake[0].x && killer.y === snake[0].y) {
              triggerZap(killer.x, killer.y);
              return;
            }
          }

          for (let j = 1; j < snake.length; j++) {
            if (killer.x === snake[j].x && killer.y === snake[j].y) {
              explosions.push({ x: killer.x, y: killer.y, t: 0 });
              addShake(5, 120);
              emitParticles(killer.x * gridSize + gridSize / 2, killer.y * gridSize + gridSize / 2, 14, 200, 360, 1.2, 3.2);
              playExplosionSound();
              killerPellets.splice(i, 1);
              setTimeout(() => respawnKillerFarAway(), 2000);
              break;
            }
          }
        }
      }

      // Gold killer movement in Area 2 (every 3 steps)
      if (currentArea === 2 && goldKiller && moveCounter % 3 === 0) {
        const dx = snake[0].x - goldKiller.x;
        const dy = snake[0].y - goldKiller.y;
        if (Math.abs(dx) > Math.abs(dy)) goldKiller.x += (dx > 0 ? 1 : -1);
        else if (dy !== 0) goldKiller.y += (dy > 0 ? 1 : -1);

        goldKiller.x = Math.max(0, Math.min(tileCountX - GOLD_KILLER_SIZE, goldKiller.x));
        goldKiller.y = Math.max(0, Math.min(tileCountY - GOLD_KILLER_SIZE, goldKiller.y));

        if (snake[0].x >= goldKiller.x && snake[0].x < goldKiller.x + GOLD_KILLER_SIZE &&
            snake[0].y >= goldKiller.y && snake[0].y < goldKiller.y + GOLD_KILLER_SIZE) {
          triggerZap(snake[0].x, snake[0].y);
          return;
        }

        for (let j = 1; j < snake.length; j++) {
          if (snake[j].x >= goldKiller.x && snake[j].x < goldKiller.x + GOLD_KILLER_SIZE &&
              snake[j].y >= goldKiller.y && snake[j].y < goldKiller.y + GOLD_KILLER_SIZE) {
            if (!goldKillerInvincible) hitGoldKiller();
            break;
          }
        }
      }

      if (currentArea === 2 && goldKillerInvincible && killerPellets.length === 0) {
        goldKillerInvincible = false;
        playForceFieldSound();
      }

      // Compute next head
      const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

      // Wrap
      if (head.x < 0) head.x = tileCountX - 1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY - 1;
      if (head.y >= tileCountY) head.y = 0;

      // Self collision
      if (!powerMode && !bodyPassthroughGrace) {
        for (let i = 1; i < snake.length; i++) {
          if (head.x === snake[i].x && head.y === snake[i].y) {
            resetGame();
            return;
          }
        }
      }

      const bigHitbox = powerMode && !powerModeWarning;

      // Killer collision
      for (let i = killerPellets.length - 1; i >= 0; i--) {
        const kx = killerPellets[i].x;
        const ky = killerPellets[i].y;
        const hitKiller = bigHitbox
          ? (kx >= head.x && kx <= head.x + 1 && ky >= head.y && ky <= head.y + 1)
          : (head.x === kx && head.y === ky);

        if (hitKiller) {
          if (powerMode) {
            score += 5;
            for (let j = 0; j < 5; j++) snake.push({ ...snake[snake.length - 1] });
            playKillerEatSound();
            addThunderFlash();
            explosions.push({ x: kx, y: ky, t: 0 });
            addShake(4, 90);
            emitParticles(kx * gridSize + gridSize / 2, ky * gridSize + gridSize / 2, 12, 180, 320, 1.0, 3.0);
            killerPellets.splice(i, 1);
            setTimeout(() => respawnKillerFarAway(), 2000);
          } else {
            triggerZap(head.x, head.y);
            return;
          }
        }
      }

      // Power pellet collision
      if (powerPellet) {
        if ((head.x === powerPellet.x || head.x === powerPellet.x + 1) &&
            (head.y === powerPellet.y || head.y === powerPellet.y + 1)) {
          activatePowerMode();
        }
      }

      // Portals
      if (currentArea === 1 && bluePortal) {
        if (head.x >= bluePortal.x && head.x < bluePortal.x + PORTAL_WIDTH &&
            head.y >= bluePortal.y && head.y < bluePortal.y + PORTAL_HEIGHT) {
          transitionToArea2();
          return;
        }
      }

      if (currentArea === 1 && redPortal) {
        if (head.x >= redPortal.x && head.x < redPortal.x + PORTAL_WIDTH &&
            head.y >= redPortal.y && head.y < redPortal.y + PORTAL_HEIGHT) {
          transitionToArea3();
          return;
        }
      }

      if (currentArea === 2 && blackPortal && !isSnakeInPortal(blackPortal)) {
        blackPortal = null;
      }

      if (currentArea === 2 && goldKiller) {
        if (head.x >= goldKiller.x && head.x < goldKiller.x + GOLD_KILLER_SIZE &&
            head.y >= goldKiller.y && head.y < goldKiller.y + GOLD_KILLER_SIZE) {
          triggerZap(head.x, head.y);
          return;
        }
      }

      if (currentArea === 2 && returnPortal) {
        if (head.x >= returnPortal.x && head.x < returnPortal.x + PORTAL_WIDTH &&
            head.y >= returnPortal.y && head.y < returnPortal.y + PORTAL_HEIGHT) {
          transitionToArea1();
          return;
        }
      }

      // Advance snake
      snake.unshift(head);

      let ate = false;
      // Orange (gold) pellet eat check  worth 5 score + 5 body
      if (currentArea === 1 && orangePellets.length) {
        const op = orangePellets[0];
        if (op) {
          const hitOrange = bigHitbox
            ? (op.x >= head.x && op.x <= head.x + 1 && op.y >= head.y && op.y <= head.y + 1)
            : (head.x === op.x && head.y === op.y);

          if (hitOrange) {
            score += 5;
            addShake(3.2, 110);
            emitParticles(op.x * gridSize + gridSize / 2, op.y * gridSize + gridSize / 2, 18, 190, 360, 1.1, 3.0);

            // Grow by 5 segments
            for (let g = 0; g < 5; g++) {
              snake.push({ ...snake[snake.length - 1] });
            }

            // Remove orange pellet; player must eat 10 more blue pellets to spawn the next
            orangePellets = [];
            blueEatenTowardOrange = 0;

            playEatSound();
            ate = true;
          }
        }
      }

      for (let i = 0; i < pellets.length; i++) {
        const px = pellets[i].x;
        const py = pellets[i].y;
        const hitPellet = bigHitbox
          ? (px >= head.x && px <= head.x + 1 && py >= head.y && py <= head.y + 1)
          : (head.x === px && head.y === py);

        if (hitPellet) {
          score++;
          // Area 1: after eating enough blue pellets, spawn 1 orange pellet (if none is present)
          if (currentArea === 1 && orangePellets.length === 0) {
            blueEatenTowardOrange++;
            if (blueEatenTowardOrange >= ORANGE_TRIGGER_COUNT) {
              trySpawnOrangePellet();
            }
          }
          addShake(1.8, 70);
          emitParticles(px * gridSize + gridSize / 2, py * gridSize + gridSize / 2, 10, 140, 300, 1.0, 2.6);
          if (currentArea === 2 && area2NoPelletRespawn) {
            pellets.splice(i, 1);
          } else {
            pellets[i] = spawnFood();
          }
          playEatSound();
          ate = true;
          break;
        }
      }

      if (!ate) {
        const tail = snake[snake.length - 1];
        // Subtle tail trail for a more premium look
        if (tail) {
          emitParticles(tail.x * gridSize + gridSize / 2, tail.y * gridSize + gridSize / 2, 2, 60, 280, 0.8, 1.8);
        }
        snake.pop();
      }
    }

    function resetGame(playSound = true) {
      if (playSound) playGameOverSound();

      stopExplosionTimer();
      stopPowerPelletTimer();
      stopPortalTimer();
      if (musicEnabled) startMusic();

      explosions = [];
      thunderFlashes = [];
      goldExplosions = [];

      snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
      prevSnake = snake.map(p => ({ ...p }));
      direction = { x: 0, y: 0 };
      queuedDirection = null;

      spawnPellets();
      score = 0;
      gameStarted = false;
      moveCounter = 0;

      powerMode = false;
      powerModeWarning = false;
      bodyPassthroughGrace = false;
      if (bodyPassthroughGraceTimer) {
        clearTimeout(bodyPassthroughGraceTimer);
        bodyPassthroughGraceTimer = null;
      }
      powerPellet = null;
      if (powerModeTimer) {
        clearTimeout(powerModeTimer);
        powerModeTimer = null;
      }

      currentArea = 1;
      bluePortal = null;
      redPortal = null;
      blackPortal = null;
      returnPortal = null;
      portalAnimTime = 0;
      goldKiller = null;
      goldKillerHP = GOLD_KILLER_MAX_HP;
      goldKillerInvincible = false;
      area2NoPelletRespawn = false;
    }

    // --- Rendering ---
    function drawPortal(portal, style) {
      const isBlack = style === 'black';
      const isRed = style === 'red';
      const px = portal.x * gridSize;
      const py = portal.y * gridSize;
      const pw = PORTAL_WIDTH * gridSize;
      const ph = PORTAL_HEIGHT * gridSize;
      const centerX = px + pw / 2;
      const centerY = py + ph / 2;

      const t = portalAnimTime * 0.001;

      // Outer glow
      const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(pw, ph));
      if (isBlack) {
        glowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
        glowGradient.addColorStop(0.5, 'rgba(20, 20, 20, 0.5)');
        glowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      } else if (isRed) {
        glowGradient.addColorStop(0, 'rgba(120, 0, 0, 0.9)');
        glowGradient.addColorStop(0.5, 'rgba(150, 30, 30, 0.5)');
        glowGradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
      } else {
        glowGradient.addColorStop(0, 'rgba(0, 0, 120, 0.9)');
        glowGradient.addColorStop(0.5, 'rgba(0, 50, 150, 0.5)');
        glowGradient.addColorStop(1, 'rgba(0, 0, 100, 0)');
      }
      ctx.fillStyle = glowGradient;
      ctx.fillRect(px - 20, py - 20, pw + 40, ph + 40);

      const bodyGradient = ctx.createLinearGradient(px, py, px + pw, py + ph);
      if (isBlack) {
        bodyGradient.addColorStop(0, '#000000');
        bodyGradient.addColorStop(0.5, '#1a1a1a');
        bodyGradient.addColorStop(1, '#000000');
      } else if (isRed) {
        bodyGradient.addColorStop(0, '#330000');
        bodyGradient.addColorStop(0.5, '#660000');
        bodyGradient.addColorStop(1, '#440000');
      } else {
        bodyGradient.addColorStop(0, '#000033');
        bodyGradient.addColorStop(0.5, '#000066');
        bodyGradient.addColorStop(1, '#000044');
      }
      ctx.fillStyle = bodyGradient;
      ctx.fillRect(px, py, pw, ph);

      const spiralCount = 3;
      for (let i = 0; i < spiralCount; i++) {
        const angle = t + (i * Math.PI * 2 / spiralCount);
        const radius = 15 + Math.sin(t * 2) * 5;
        ctx.beginPath();
        for (let tt = 0; tt < Math.PI * 4; tt += 0.2) {
          const spiralRadius = radius * (1 - tt / (Math.PI * 6));
          const sx = centerX + Math.cos(angle + tt) * spiralRadius * (pw / ph);
          const sy = centerY + Math.sin(angle + tt) * spiralRadius;
          if (sx >= px && sx <= px + pw && sy >= py && sy <= py + ph) {
            if (tt === 0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
          }
        }
        ctx.strokeStyle = isBlack
          ? `rgba(60, 60, 60, ${0.6 - i * 0.15})`
          : (isRed ? `rgba(255, 120, 120, ${0.6 - i * 0.15})` : `rgba(100, 150, 255, ${0.6 - i * 0.15})`);
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      const particleCount = 6;
      for (let i = 0; i < particleCount; i++) {
        const particleTime = (t + i * 1.5) % 3;
        const particleY = py + ph - (particleTime / 3) * ph;
        const wobble = Math.sin(t * 3 + i) * 10;
        const particleX = centerX + wobble;
        const particleSize = 3 * (1 - particleTime / 3);
        const alpha = 1 - particleTime / 3;
        if (particleY >= py && particleY <= py + ph) {
          ctx.beginPath();
          ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
          ctx.fillStyle = isBlack
            ? `rgba(100, 100, 100, ${alpha})`
            : (isRed ? `rgba(255, 170, 170, ${alpha})` : `rgba(150, 200, 255, ${alpha})`);
          ctx.fill();
        }
      }

      ctx.strokeStyle = isBlack ? '#333333' : (isRed ? '#ff4444' : '#4488ff');
      ctx.lineWidth = 3;
      ctx.shadowColor = isBlack ? '#000000' : (isRed ? '#ff0000' : '#0066ff');
      ctx.shadowBlur = 15 + Math.sin(t * 2) * 5;
      ctx.strokeRect(px, py, pw, ph);
      ctx.shadowBlur = 0;

      ctx.strokeStyle = isBlack
        ? 'rgba(80, 80, 80, 0.5)'
        : (isRed ? 'rgba(255, 160, 160, 0.5)' : 'rgba(100, 180, 255, 0.5)');
      ctx.lineWidth = 1;
      ctx.strokeRect(px + 3, py + 3, pw - 6, ph - 6);
    }

    function drawBackground() {
      // Slight vignette + optional subtle grid (pro feel)
      const w = window.innerWidth;
      const h = window.innerHeight;

      // Base fill based on area / power mode
      if (currentArea === 2) {
        ctx.fillStyle = AREA_2_COLOR;
        ctx.fillRect(0, 0, w, h);
      } else if (currentArea === 3) {
        ctx.fillStyle = AREA_3_COLOR;
        ctx.fillRect(0, 0, w, h);
      } else if (powerMode && !powerModeWarning) {
        ctx.fillStyle = "#001f4d";
        ctx.fillRect(0, 0, w, h);
      } else if (powerModeWarning) {
        const elapsed = Date.now() - powerModeWarningStart;
        const fadeProgress = Math.min(elapsed / POWER_MODE_WARNING_DURATION, 1);
        const blue = Math.floor(77 * (1 - fadeProgress));
        ctx.fillStyle = `rgb(0, 10, ${blue})`;
        ctx.fillRect(0, 0, w, h);
      } else {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
      }

      // Animated grid (Area 1) + parallax for a more finished look
      if (currentArea === 1) {
        const offX = (bgTime * 0.02) % gridSize;
        const offY = (bgTime * 0.015) % gridSize;

        ctx.save();
        ctx.globalAlpha = 0.055;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;

        for (let x = -gridSize; x <= w + gridSize; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x + 0.5 + offX, 0);
          ctx.lineTo(x + 0.5 + offX, h);
          ctx.stroke();
        }
        for (let y = -gridSize; y <= h + gridSize; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y + 0.5 + offY);
          ctx.lineTo(w, y + 0.5 + offY);
          ctx.stroke();
        }

        // Secondary larger grid (very subtle)
        ctx.globalAlpha = 0.03;
        const big = gridSize * 5;
        const boffX = (bgTime * 0.01) % big;
        const boffY = (bgTime * 0.008) % big;
        for (let x = -big; x <= w + big; x += big) {
          ctx.beginPath();
          ctx.moveTo(x + 0.5 + boffX, 0);
          ctx.lineTo(x + 0.5 + boffX, h);
          ctx.stroke();
        }
        for (let y = -big; y <= h + big; y += big) {
          ctx.beginPath();
          ctx.moveTo(0, y + 0.5 + boffY);
          ctx.lineTo(w, y + 0.5 + boffY);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Vignette
      const g = ctx.createRadialGradient(w / 2, h / 2, Math.min(w, h) * 0.1, w / 2, h / 2, Math.max(w, h) * 0.75);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.55)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);
    }

    function draw(alpha) {
      const w = window.innerWidth;
      const h = window.innerHeight;

      ctx.save();
      ctx.translate(cameraShake.x, cameraShake.y);
      drawBackground();

      // Thunder flashes
      for (let flash of thunderFlashes) {
        ctx.fillStyle = `rgba(255, 255, 255, ${flash.opacity})`;
        ctx.fillRect(0, 0, w, h);
      }

      // Particles (subtle glow)
      if (particles.length) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const pr = Math.max(0, 1 - p.life / p.maxLife);
          const r = p.size * (0.7 + (1 - pr) * 0.8);
          ctx.globalAlpha = 0.25 * pr;
          ctx.beginPath();
          ctx.arc(p.x, p.y, r * 4.0, 0, Math.PI * 2);
          ctx.fillStyle = '#00bfff';
          ctx.fill();
          ctx.globalAlpha = 0.65 * pr;
          ctx.beginPath();
          ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
          ctx.fillStyle = '#ffffff';
          ctx.fill();
        }
        ctx.restore();
      }

      // Helpers to interpolate snake segments
      const snakePowered = powerMode && !powerModeWarning;
      const snakeSize = snakePowered ? gridSize * 2 : gridSize;

      function interpPoint(i) {
        const a = prevSnake[i] || snake[i];
        const b = snake[i] || prevSnake[i];
        if (!a || !b) return { x: b?.x ?? a.x, y: b?.y ?? a.y };

        const dx = wrapDelta(a.x, b.x, tileCountX);
        const dy = wrapDelta(a.y, b.y, tileCountY);
        if (dx === null || dy === null) {
          return { x: b.x, y: b.y };
        }
        return { x: lerp(a.x, b.x, alpha), y: lerp(a.y, b.y, alpha) };
      }
      // Snake body (smooth ribbon)
      if (snake.length > 1) {
        const pts = []; // pixel centers
        const tiles = []; // tile coords to detect wrap breaks
        for (let i = 0; i < snake.length; i++) {
          const sp = interpPoint(i);
          tiles.push({ x: sp.x, y: sp.y });
          pts.push({
            x: sp.x * gridSize + snakeSize * 0.5,
            y: sp.y * gridSize + snakeSize * 0.5
          });
        }

        // Split the ribbon into segments when wrapping occurs.
        // This prevents the tail from "flashing" across the whole screen when you cross an edge.
        const segments = [];
        let cur = [];
        for (let i = 0; i < pts.length; i++) {
          if (i > 0) {
            const dx = Math.abs(tiles[i].x - tiles[i - 1].x);
            const dy = Math.abs(tiles[i].y - tiles[i - 1].y);
            if (dx > 1 || dy > 1) {
              if (cur.length) segments.push(cur);
              cur = [];
            }
          }
          cur.push(pts[i]);
        }
        if (cur.length) segments.push(cur);

        function strokeSpline(points) {
          if (points.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length - 1; i++) {
            const mx = (points[i].x + points[i + 1].x) * 0.5;
            const my = (points[i].y + points[i + 1].y) * 0.5;
            ctx.quadraticCurveTo(points[i].x, points[i].y, mx, my);
          }
          ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
          ctx.stroke();
        }

        // A professional look: rounded, glowing spline (render each segment separately)
        const head = pts[0];
        const tail = pts[pts.length - 1];
        const grad = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
        if (snakePowered) {
          grad.addColorStop(0, 'rgba(255,60,60,0.95)');
          grad.addColorStop(1, 'rgba(255,0,0,0.55)');
        } else {
          grad.addColorStop(0, 'rgba(0,255,170,0.95)');
          grad.addColorStop(1, 'rgba(0,180,80,0.55)');
        }

        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = grad;
        ctx.lineWidth = snakePowered ? snakeSize * 0.92 : snakeSize * 0.80;
        ctx.shadowColor = snakePowered ? 'rgba(255,0,0,0.55)' : 'rgba(0,255,140,0.35)';
        ctx.shadowBlur = snakePowered ? 26 : 18;

        for (const seg of segments) strokeSpline(seg);

        // Inner highlight pass
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.22;
        ctx.lineWidth = snakePowered ? snakeSize * 0.44 : snakeSize * 0.38;
        ctx.strokeStyle = snakePowered ? 'rgba(255,220,220,0.9)' : 'rgba(220,255,240,0.9)';
        for (const seg of segments) strokeSpline(seg);

        ctx.restore();
      }

      // Snake head
      if (snake.length > 0) {
        const p = interpPoint(0);
        const headX = p.x * gridSize;
        const headY = p.y * gridSize;

        ctx.fillStyle = snakePowered ? "#ff0000" : "#89CFF0";
        ctx.shadowColor = snakePowered ? 'rgba(255,0,0,0.45)' : 'rgba(137,207,240,0.35)';
        ctx.shadowBlur = 14;
        ctx.fillRect(headX, headY, snakeSize, snakeSize);
        ctx.shadowBlur = 0;

        if (snakePowered) {
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(headX + 12, headY + 14, 5, 0, Math.PI * 2);
          ctx.arc(headX + 28, headY + 14, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(headX + 20, headY + 24, 10, 0.2 * Math.PI, 0.8 * Math.PI);
          ctx.stroke();
        } else {
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.arc(headX + 6, headY + 7, 3, 0, Math.PI * 2);
          ctx.arc(headX + 14, headY + 7, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(headX + 10, headY + 11, 5, 0.2 * Math.PI, 0.8 * Math.PI);
          ctx.stroke();
        }
      }

      // Only show pellets after game has started
      if (gameStarted) {
        const bigHitbox = powerMode && !powerModeWarning;

        // Helper: glossy block (matches the head style: crisp square + subtle glow + highlight)
        function drawGlossyBlock(px, py, size, fill, glow) {
          ctx.save();
          ctx.fillStyle = fill;
          ctx.shadowColor = glow || fill;
          ctx.shadowBlur = 14;
          ctx.fillRect(px, py, size, size);
          ctx.shadowBlur = 0;

          // Soft diagonal highlight
          const g = ctx.createLinearGradient(px, py, px + size, py + size);
          g.addColorStop(0, 'rgba(255,255,255,0.40)');
          g.addColorStop(0.35, 'rgba(255,255,255,0.12)');
          g.addColorStop(1, 'rgba(0,0,0,0.00)');
          ctx.fillStyle = g;
          ctx.fillRect(px, py, size, size);
          ctx.restore();
        }

        // Food pellets (block style, same glossy vibe as the snake head)
        for (let pellet of pellets) {
          const px = pellet.x * gridSize;
          const py = pellet.y * gridSize;
          drawGlossyBlock(px, py, gridSize, '#00bfff', 'rgba(0,191,255,0.55)');
        }
        // Orange (gold) pellet (Area 1 only)  matching glossy block style
        if (currentArea === 1 && orangePellets.length) {
          const pellet = orangePellets[0];
          if (pellet) {
            const px = pellet.x * gridSize;
            const py = pellet.y * gridSize;

            // Pop-in animation when it spawns
            let scale = 1.0;
            let ring = 0.0;
            if (orangeSpawnAnim.active && orangeSpawnAnim.x === pellet.x && orangeSpawnAnim.y === pellet.y) {
              const pr = Math.min(orangeSpawnAnim.t / orangeSpawnAnim.duration, 1);
              // Ease-out back to 1.0
              const ease = 1 - Math.pow(1 - pr, 3);
              scale = 1.55 - 0.55 * ease;
              ring = pr;
            }

            const cx = px + gridSize / 2;
            const cy = py + gridSize / 2;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(scale, scale);
            ctx.translate(-cx, -cy);
            drawGlossyBlock(px, py, gridSize, '#ff9900', 'rgba(255,153,0,0.60)');
            ctx.restore();

            // Expanding ring (subtle)
            if (ring > 0 && ring < 1) {
              ctx.beginPath();
              ctx.arc(cx, cy, 6 + ring * 26, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(255,180,60,${0.55 * (1 - ring)})`;
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          }
        }

        // Killer pellets (block style).
        // When power pellet is active, bring back the frowny/scared faces.
        for (let killer of killerPellets) {
          const kx = killer.x * gridSize;
          const ky = killer.y * gridSize;

          // Scared during power mode (and blinking during warning)
          let scared = powerMode && !powerModeWarning;
          if (powerModeWarning) {
            const elapsed = Date.now() - powerModeWarningStart;
            const blinkPhase = Math.floor(elapsed / 833) % 2;
            scared = blinkPhase === 0;
          }

          if (scared) {
            // Scared gray blocks with frowny face (edible)
            drawGlossyBlock(kx, ky, gridSize, '#888', 'rgba(200,240,255,0.45)');

            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(kx + 6, ky + 6, 3, 0, Math.PI * 2);
            ctx.arc(kx + 14, ky + 6, 3, 0, Math.PI * 2);
            ctx.fill();

            // Frown
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(kx + 10, ky + 16, 4, 1.2 * Math.PI, 1.8 * Math.PI);
            ctx.stroke();
          } else {
            // Normal red killers (deadly)
            drawGlossyBlock(kx, ky, gridSize, '#ff3333', 'rgba(255,60,60,0.55)');
          }
        }


        // Power pellet
        if (powerPellet) {
          const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
          ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
          ctx.shadowColor = 'rgba(255,255,255,0.45)';
          ctx.shadowBlur = 14;
          ctx.fillRect(powerPellet.x * gridSize, powerPellet.y * gridSize, gridSize * 2, gridSize * 2);
          ctx.shadowBlur = 0;

          ctx.fillStyle = "#ffff00";
          const sparkleX = powerPellet.x * gridSize + gridSize + Math.sin(Date.now() / 150) * 8;
          const sparkleY = powerPellet.y * gridSize + gridSize + Math.cos(Date.now() / 150) * 8;
          ctx.beginPath();
          ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
          ctx.fill();
        }


        // Draw portals in Area 1
        if (currentArea === 1 && bluePortal) {
          drawPortal(bluePortal, 'blue');
        }
        if (currentArea === 1 && redPortal) {
          drawPortal(redPortal, 'red');
        }
      }

      // Black exit portal in Area 2
      if (currentArea === 2 && blackPortal) drawPortal(blackPortal, 'black');

      // Gold boss
      if (currentArea === 2 && goldKiller) {
        const gx = goldKiller.x * gridSize;
        const gy = goldKiller.y * gridSize;
        const gSize = GOLD_KILLER_SIZE * gridSize;
        const centerX = gx + gSize / 2;
        const centerY = gy + gSize / 2;

        if (goldKillerInvincible) {
          const time = Date.now() / 200;
          for (let r = 0; r < 3; r++) {
            const ripplePhase = (time + r * 2) % 6;
            const rippleRadius = (gSize / 2) + ripplePhase * 15;
            const rippleAlpha = Math.max(0, 0.5 - ripplePhase * 0.08);
            ctx.beginPath();
            ctx.arc(centerX, centerY, rippleRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(100, 200, 255, ${rippleAlpha})`;
            ctx.lineWidth = 2;
            ctx.stroke();
          }

          const flicker = 0.4 + Math.sin(Date.now() / 50) * 0.1 + Math.random() * 0.1;
          ctx.fillStyle = `rgba(100, 200, 255, ${flicker})`;
          ctx.fillRect(gx, gy, gSize, gSize);

          ctx.strokeStyle = `rgba(150, 220, 255, ${flicker * 0.5})`;
          ctx.lineWidth = 1;
          for (let y = gy; y < gy + gSize; y += 4) {
            ctx.beginPath();
            ctx.moveTo(gx, y);
            ctx.lineTo(gx + gSize, y);
            ctx.stroke();
          }

          ctx.strokeStyle = '#66ccff';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 20 + Math.sin(Date.now() / 100) * 10;
          ctx.strokeRect(gx, gy, gSize, gSize);
          ctx.shadowBlur = 0;

          ctx.fillStyle = `rgba(200, 240, 255, ${flicker + 0.2})`;
          ctx.beginPath();
          ctx.arc(gx + 12, gy + 14, 5, 0, Math.PI * 2);
          ctx.arc(gx + gSize - 12, gy + 14, 5, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = `rgba(200, 240, 255, ${flicker + 0.2})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(gx + 5, gy + 8);
          ctx.lineTo(gx + 17, gy + 12);
          ctx.moveTo(gx + gSize - 5, gy + 8);
          ctx.lineTo(gx + gSize - 17, gy + 12);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(gx + gSize / 2, gy + gSize - 8, 8, 1.2 * Math.PI, 1.8 * Math.PI);
          ctx.stroke();
        } else {
          const goldGradient = ctx.createLinearGradient(gx, gy, gx + gSize, gy + gSize);
          goldGradient.addColorStop(0, '#ffd700');
          goldGradient.addColorStop(0.3, '#ffec8b');
          goldGradient.addColorStop(0.5, '#fff8dc');
          goldGradient.addColorStop(0.7, '#ffec8b');
          goldGradient.addColorStop(1, '#daa520');
          ctx.fillStyle = goldGradient;
          ctx.shadowColor = 'rgba(255,215,0,0.35)';
          ctx.shadowBlur = 14;
          ctx.fillRect(gx, gy, gSize, gSize);
          ctx.shadowBlur = 0;

          const shimmerX = gx + (Math.sin(Date.now() / 200) + 1) * (gSize / 2 - 5);
          const shimmerY = gy + (Math.cos(Date.now() / 200) + 1) * (gSize / 2 - 5);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.beginPath();
          ctx.arc(shimmerX, shimmerY, 5, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 2;
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 10 + Math.sin(Date.now() / 150) * 5;
          ctx.strokeRect(gx, gy, gSize, gSize);
          ctx.shadowBlur = 0;

          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(gx + 12, gy + 14, 5, 0, Math.PI * 2);
          ctx.arc(gx + gSize - 12, gy + 14, 5, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(gx + 5, gy + 8);
          ctx.lineTo(gx + 17, gy + 12);
          ctx.moveTo(gx + gSize - 5, gy + 8);
          ctx.lineTo(gx + gSize - 17, gy + 12);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(gx + gSize / 2, gy + gSize - 8, 8, 1.2 * Math.PI, 1.8 * Math.PI);
          ctx.stroke();
        }
      }

      // Return portal
      if (currentArea === 2 && returnPortal) drawPortal(returnPortal, 'black');

      // Explosions (time-based)
      for (let explosion of explosions) {
        const centerX = explosion.x * gridSize + gridSize / 2;
        const centerY = explosion.y * gridSize + gridSize / 2;
        const progress = Math.min(explosion.t / 220, 1);
        const maxRadius = 60 * progress;

        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, ${100 - progress * 100}, 0, ${1 - progress})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        const particleCount = 8;
        for (let i = 0; i < particleCount; i++) {
          const angle = (i / particleCount) * Math.PI * 2;
          const px = centerX + Math.cos(angle) * maxRadius * 0.7;
          const py = centerY + Math.sin(angle) * maxRadius * 0.7;
          const size = 6 * (1 - progress);
          ctx.fillStyle = (Math.floor(explosion.t / 30) % 2 === 0) ? '#ff6600' : '#ffcc00';
          ctx.fillRect(px - size / 2, py - size / 2, size, size);
        }

        if (progress < 0.35) {
          ctx.beginPath();
          ctx.arc(centerX, centerY, 15 - progress * 12, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.fill();
        }
      }

      for (let explosion of goldExplosions) {
        const centerX = explosion.x * gridSize + gridSize / 2;
        const centerY = explosion.y * gridSize + gridSize / 2;
        const progress = Math.min(explosion.t / 420, 1);
        const maxRadius = 100 * progress;

        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 215, 0, ${1 - progress})`;
        ctx.lineWidth = 6;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius * 0.7, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 236, 139, ${1 - progress})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        const particleCount = 12;
        for (let i = 0; i < particleCount; i++) {
          const angle = (i / particleCount) * Math.PI * 2 + explosion.t * 0.003;
          const px = centerX + Math.cos(angle) * maxRadius * 0.6;
          const py = centerY + Math.sin(angle) * maxRadius * 0.6;
          const size = 8 * (1 - progress);
          ctx.fillStyle = (Math.floor(explosion.t / 35) % 2 === 0) ? '#ffd700' : '#fff8dc';
          ctx.beginPath();
          ctx.arc(px, py, size, 0, Math.PI * 2);
          ctx.fill();
        }

        if (progress < 0.4) {
          const flashRadius = 25 - progress * 20;
          const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, flashRadius);
          grad.addColorStop(0, '#ffffff');
          grad.addColorStop(0.5, '#ffd700');
          grad.addColorStop(1, 'rgba(255, 215, 0, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(centerX, centerY, flashRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Zap animation (time-based)
      if (zapAnimation.active) {
        const progress = Math.min(zapAnimation.t / zapAnimation.duration, 1);
        const centerX = zapAnimation.x * gridSize + gridSize / 2;
        const centerY = zapAnimation.y * gridSize + gridSize / 2;
        const boltCount = 8;
        const maxRadius = 80 + progress * 130;

        ctx.strokeStyle = (Math.floor(zapAnimation.t / 40) % 2 === 0) ? '#fff' : '#ff0';
        ctx.lineWidth = 3;

        for (let i = 0; i < boltCount; i++) {
          const angle = (i / boltCount) * Math.PI * 2 + progress * 2.0;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          let x = centerX;
          let y = centerY;
          const segments = 5;
          for (let j = 0; j < segments; j++) {
            const pr = (j + 1) / segments;
            const targetX = centerX + Math.cos(angle) * maxRadius * pr;
            const targetY = centerY + Math.sin(angle) * maxRadius * pr;
            x = targetX + (Math.random() - 0.5) * 20;
            y = targetY + (Math.random() - 0.5) * 20;
            ctx.lineTo(x, y);
          }
          ctx.stroke();
        }

        // Flash snake
        ctx.fillStyle = (Math.floor(zapAnimation.t / 40) % 2 === 0) ? '#fff' : '#ff0';
        for (let part of snake) {
          ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
        }
      }

      ctx.restore();

      // HUD updates
      scoreLabelEl.textContent = String(score);
      areaLabelEl.textContent = `Area ${currentArea}`;
      areaDotEl.style.background = currentArea === 2 ? '#4488ff' : (currentArea === 3 ? '#ff4444' : '#00ffff');
      areaDotEl.style.boxShadow = currentArea === 2
        ? '0 0 10px rgba(68,136,255,0.65)'
        : (currentArea === 3 ? '0 0 10px rgba(255,68,68,0.65)' : '0 0 10px rgba(0,255,255,0.65)');

      // Boss HUD line (kept in canvas previously); now just add to area label when relevant
      if (currentArea === 2 && goldKiller) {
        if (goldKillerInvincible) {
          areaLabelEl.textContent = `Area 2  Boss HP ${goldKillerHP}/${GOLD_KILLER_MAX_HP}  SHIELDED (${killerPellets.length} left)`;
        } else {
          areaLabelEl.textContent = `Area 2  Boss HP ${goldKillerHP}/${GOLD_KILLER_MAX_HP}`;
        }
      }
    }

    // --- Main loop: rAF @ ~60fps + fixed timestep logic ---
    let lastTime = performance.now();
    let accumulator = 0;

    // FPS meter
    let fpsSmoothed = 60;

    function frame(now) {
      const dt = Math.min(50, now - lastTime);
      lastTime = now;

      // Time-based animation updates
      portalAnimTime += dt;

      // Background drift for animated grid
      bgTime += dt;

      // Camera shake update
      if (cameraShake.duration > 0) {
        cameraShake.t += dt;
        const pr = Math.min(cameraShake.t / cameraShake.duration, 1);
        const amp = cameraShake.intensity * (1 - pr);
        cameraShake.tx = (Math.random() * 2 - 1) * amp;
        cameraShake.ty = (Math.random() * 2 - 1) * amp;
        cameraShake.x = cameraShake.x * 0.72 + cameraShake.tx * 0.28;
        cameraShake.y = cameraShake.y * 0.72 + cameraShake.ty * 0.28;
        if (pr >= 1) {
          cameraShake.duration = 0;
          cameraShake.intensity = 0;
        }
      } else {
        // Ease back to center
        cameraShake.x *= 0.75;
        cameraShake.y *= 0.75;
      }

      // Particle simulation
      if (particles.length) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life += dt;
          if (p.life >= p.maxLife) {
            particles.splice(i, 1);
            continue;
          }
          const dts = dt / 1000;
          p.x += p.vx * dts;
          p.y += p.vy * dts;
          // Soft damping
          const damp = Math.pow(0.90, dt / 16.666);
          p.vx *= damp;
          p.vy *= damp;
        }
      }


      // Tail glow emission (cheap + subtle)
      if (gameStarted && snake.length > 2) {
        // Emit at tail (grid-based, rendered as glow particles)
        const tail = snake[snake.length - 1];
        const tx = tail.x * gridSize + gridSize * 0.5;
        const ty = tail.y * gridSize + gridSize * 0.5;
        // Throttle a bit so we don't spam particles
        if ((now|0) % 2 === 0) emitParticles(tx, ty, 2, 90, 320, 0.8, 2.0);
      }
      // Update zap animation time
      if (zapAnimation.active) {
        zapAnimation.t += dt;
        if (zapAnimation.t >= zapAnimation.duration) {
          zapAnimation.active = false;
          resetGame(false);
        }
      }

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].t += dt;
        if (explosions[i].t > 220) explosions.splice(i, 1);
      }
      for (let i = goldExplosions.length - 1; i >= 0; i--) {
        goldExplosions[i].t += dt;
        if (goldExplosions[i].t > 420) goldExplosions.splice(i, 1);
      }

      // Thunder flashes
      for (let i = thunderFlashes.length - 1; i >= 0; i--) {
        thunderFlashes[i].t += dt;
        thunderFlashes[i].opacity = Math.max(0, 0.8 - thunderFlashes[i].t * 0.004);
        if (thunderFlashes[i].opacity <= 0) thunderFlashes.splice(i, 1);
      }

      // Orange spawn anim timer
      if (orangeSpawnAnim.active) {
        orangeSpawnAnim.t += dt;
        if (orangeSpawnAnim.t >= orangeSpawnAnim.duration) {
          orangeSpawnAnim.active = false;
        }
      }

      // Fixed logic
      accumulator += dt;
      const step = getStepMs();
      while (accumulator >= step) {
        updateLogicStep();
        accumulator -= step;
      }
      const alpha = step > 0 ? (accumulator / step) : 0;

      draw(alpha);

      // FPS
      const fpsInstant = 1000 / Math.max(1, dt);
      fpsSmoothed = fpsSmoothed * 0.92 + fpsInstant * 0.08;
      fpsLabelEl.textContent = `FPS: ${fpsSmoothed.toFixed(0)}`;

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);

    // --- Input ---
    function setQueuedDirection(dx, dy) {
      // Buffer direction for the next logic step (smoother turns)
      queuedDirection = { x: dx, y: dy };
    }

    document.addEventListener("keydown", e => {
      initAudio();
      startPrompt.style.display = 'none';

      // Area 2 cheat
      if (e.key === "2" && currentArea === 2 && goldKiller) {
        defeatGoldBossCheat();
        return;
      }

      // Start with length 50 (debug)
      if (!gameStarted && direction.x === 0 && direction.y === 0 && e.key === "1") {
        direction = { x: 1, y: 0 };
        const targetLength = 50;
        while (snake.length < targetLength) {
          snake.push({ ...snake[snake.length - 1] });
        }
        prevSnake = snake.map(p => ({ ...p }));
        return;
      }

      // TEST portals in Area 1
      if (e.key === "3" && currentArea === 1) {
        bluePortal = null;
        redPortal = null;
        spawnRedPortal();
        return;
      }
      if (e.key === "4" && currentArea === 1) {
        bluePortal = null;
        redPortal = null;
        spawnBluePortal();
        return;
      }

      if (e.key === "ArrowUp") setQueuedDirection(0, -1);
      if (e.key === "ArrowDown") setQueuedDirection(0, 1);
      if (e.key === "ArrowLeft") setQueuedDirection(-1, 0);
      if (e.key === "ArrowRight") setQueuedDirection(1, 0);
    });

    document.addEventListener("click", () => {
      initAudio();
      startPrompt.style.display = 'none';
    });
  </script>
</body>
</html>
